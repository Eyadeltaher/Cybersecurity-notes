\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor}
\lstset{numbers=none, basicstyle=\ttfamily}
\renewcommand{\lstlistingname}

\geometry{a4paper, left=20mm, right=20mm, top=20mm, bottom=20mm}
\title{CSRF notes}
\author{Eyad Islam El-Taher}

\begin{document}
\maketitle

\section*{Introduction}
\textbf {CSRF (Cross-Site Request Forgery)} $\Longrightarrow$ A web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other. 

\section*{CSRF vulnerabilities happen when}
CSRF vulnerabilities happen when a web application relies solely on the automatic submission of a user's credentials (like session cookies) to authenticate a request, without requiring any other proof that the user actually intended to perform that action.\\

\vspace{5px}
\textbf{\underline{Key conditions that must be present for a CSRF attack to be possible:}}
\begin{itemize}
    \item \textbf{Cookie-Based Session Handling:} The application uses session cookies to identify the user. The browser automatically sends these cookies with every request to the domain.
    \item \textbf{No Unpredictable Tokens:} The application does not use CSRF tokens (unique, secret, and unpredictable values) to validate that the request came from a legitimate source on its own site.  (CSRF tokens can be manipulate)
    \item \textbf{No Additional Confirmation:} The application does not require re-authentication (e.g., password) for sensitive actions.
    	\item \textbf{Predictable Request Parameters:} The attacker can reliably guess the parameters needed for a state-changing request (e.g., changing an email, transferring funds).
\end{itemize}

\section*{CSRF vulnerabilities happen where}
CSRF vulnerabilities happen in the web application's server-side code, specifically in its handling of state-changing HTTP requests.

\begin{itemize}
	\item \textbf{User Account Settings:} Changing a password, updating an email address.        
	\item \textbf{E-commerce Functions:} Adding items to a cart, applying discount coupons, making a purchase.
	\item \textbf{Financial Transactions:} Transferring funds between accounts.
	\item \textbf{Social Media \& Content:} Posting a status, sending a message, liking a post.
	\item \textbf{Admin Functions:} Promoting a user to an admin, deleting user accounts.
\end{itemize}

\section*{How CSRF vulnerabilities effect on users}

\begin{itemize}
    \item \textbf{Unauthorized Financial Transactions:} An attacker could force a user to transfer money out of their bank or brokerage account without their knowledge.
    \item \textbf{Account Takeover:} An attacker can change the victim's email address and/or password, effectively locking them out of their own account and giving the attacker full control.
         
    \item \textbf{Data Theft and Privacy Breach:} While CSRF doesn't typically steal data directly, an attacker could change privacy settings to expose private data or use it as a stepping stone for further attacks.
    \item \textbf{Reputational Damage and Social Embarrassment:} An attacker could force a user to post embarrassing status updates, send offensive messages to friends, or delete important content from their social media profiles.
    \item \textbf{Fraudulent Purchases:} On an e-commerce site, an attacker could make the victim purchase items to be shipped to the attacker's address.
\end{itemize}

\section*{How CSRF Works:}

\begin{itemize}
    \item \textbf{Step 1:} The victim logs into a trusted site (e.g., good-website.com), which authenticates them and sets a session cookie in their browser.
    \item \textbf{Step 2:} The victim, in a different tab, visits a malicious site created by the attacker (evil-website.com).
         
    \item \textbf{Step 3:} The malicious site contains hidden HTML that automatically sends a request to the trusted site (good-website.com). This is the forged request.
    \item \textbf{Step 4:} The victim's browser, being loyal, sees a request going to good-website.com and automatically attaches the valid session cookie from Step 1.
    \item \textbf{Step 5:} The trusted site (good-website.com) receives the request with a valid session cookie. It thinks, "This is a legitimate request from my logged-in user!" and processes it.
    \item \textbf{Step 6:} The action is completed without the victim's knowledge or consent.
\end{itemize}

\section*{How to construct a CSRF attack:}
The easiest way to construct a CSRF exploit is using the CSRF PoC generator that is built in to Burp Suite Professional: 

\begin{itemize}
    \item \textbf{Step 1:} Select a request anywhere in Burp Suite Professional that you want to test or exploit. 
    \item \textbf{Step 2:} From the right-click context menu, select Engagement tools / Generate CSRF PoC. 
         
    \item \textbf{Step 3:} Burp Suite will generate some HTML that will trigger the selected request (minus cookies, which will be added automatically by the victim's browser). 
    \item \textbf{Step 4:} You can tweak various options in the CSRF PoC generator to fine-tune aspects of the attack. You might need to do this in some unusual situations to deal with quirky features of requests. 
    \item \textbf{Step 5:} Copy the generated HTML into a web page, view it in a browser that is logged in to the vulnerable website, and test whether the intended request is issued successfully and the desired action occurs. 
\end{itemize}

\section*{How to deliver a CSRF exploit:}
 The delivery mechanisms for cross-site request forgery attacks are essentially the same as for reflected XSS. Typically, the attacker will place the malicious HTML onto a website that they control, and then induce victims to visit that website. This might be done by feeding the user a link to the website, via an email or social media message. Or if the attack is placed into a popular website (for example, in a user comment), they might just wait for users to visit the website.
 \vspace{5px}
 
Note that some simple CSRF exploits employ the GET method and can be fully self-contained with a single URL on the vulnerable website. In this situation, the attacker may not need to employ an external site, and can directly feed victims a malicious URL on the vulnerable domain.

\section*{Common defences against CSRF:}
\begin{itemize}
    \item CSRF tokens
    \item SameSite cookies
    \item Referer-based validation
\end{itemize}

\newpage

\section*{CSRF tokens bypass}
A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim. 

\begin{enumerate}
	\item \textbf{If CSRF token depends on request method}\\
	Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used. 
	\begin{itemize}
    \item From the right-click context menu, select change request method $\Longrightarrow$ to switch between POST and GET methods
    \item From the right-click context menu, select Engagement tools / Generate CSRF PoC.
\end{itemize}
	\item \textbf{If CSRF token depends on token being present}\\
	Some applications correctly validate the token when it is present but skip the validation if the token is omitted.\\
	if the POSR request body like this
	        \begin{lstlisting}[frame=single]
email=saaaaadfds%40gmail.com&csrf=iHMm0Q4MbEGvSbjwPWCRmKtPfwvyXDFv
            \end{lstlisting}
            
            remove the CSRF token 
            	\begin{lstlisting}[frame=single]
	            email=saaaaadfds%40gmail.com
            \end{lstlisting}
            
     \item \textbf{If CSRF token is not tied to the user session}\\
	 Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.\\
	 
In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

	\item \textbf{If CSRF token is tied to a non-session cookie}\\
	Some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together

            	\begin{lstlisting}[frame=single]
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6
atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
            \end{lstlisting}
            
\underline{We have to see if the CSRF token is tied to CSRF cookie NOT the session cookie}\\
\textbf{Step 1:} Check if the CSRF token is tied to CSRF cookie
\begin{itemize}
    \item Sumbit an invalid CSRF token
    \item Sumbit a valid CSRF token but from another user (from private window)
\end{itemize}

\textbf{Step 2:} Check if the CSRF token is tied to CSRF cookie NOT the session cookie
\begin{itemize}
    \item Sumbit a valid CSRF token and CSRF cookie from another user to see if the session cookie also tied to them or not
\end{itemize}
if not this is good news that means that the session handling system and the csrf defense mechanism are not tied together so what we need in order to exploit this vulnerability is to be able to inject an http cookie called csrf key and inject our own\\
The idea is to make a malicious website that inject our own csrf cookie into the user browser
\newpage
the CSRF POS
            	\begin{lstlisting}[frame=single]
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
	<body>
		<form action="https://website.nett\/my-account/change-ema
		il" method="POST">
		
			<input type="hidden" name="email" value="testma
			il310&#64;normal&#45;user&#46;net" />
			
			<input type="hidden" name="csrf" value="QHBtrtc
			T4hitwv8Q6I2DVEYLwBJnVSpn" />
			
			<input type="submit" value="Submit request" />
		</form>
		
<img src="https://website.net/?search=sdfdsfdsf%0D%0ASet-Cookie%3A+cs
rfKey%3Dk6iDX1lTVk0e0CuPbGPAamOUVhBZ0HNX" onerror="document.forms[0].subm
it()">
</body>
</html>
            \end{lstlisting}
So when the user open the link his browser will set the hacker's csrfkey cookie and by using the hacker CSRF token also $\Longrightarrow$ the attacker is able to change the email

\item \textbf{If CSRF token is simply duplicated in a cookie}\\
Some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF
			\begin{lstlisting}[frame=single]
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFy

csrf=R8ov2YBfTYmzFy&email=wiener@normal-user.com
            \end{lstlisting}
The attacker can again perform a CSRF attack if the website contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack. 


\end{enumerate}


\section*{SameSite cookies bypass}
 SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. SameSite cookie restrictions provide partial protection against a variety of cross-site attacks, including CSRF, cross-site leaks, and some CORS exploits.\\

Since 2021, Chrome applies Lax SameSite restrictions by default if the website that issues the cookie doesn't explicitly set its own restriction level. This is a proposed standard, and we expect other major browsers to adopt this behavior in the future. As a result, it's essential to have solid grasp of how these restrictions work, as well as how they can potentially be bypassed, in order to thoroughly test for cross-site attack vectors

\subsection*{What is a site in the context of SameSite cookies?}
 In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like .com or .net, plus one additional level of the domain name. This is often referred to as the TLD+1.\\

When determining whether a request is same-site or not, the URL scheme is also taken into consideration. This means that a link from "http://app.example.com" to "https://app.example.com" is treated as cross-site by most browsers. 


\begin{lstlisting}[frame=single]
			https://app.example.com
			  |            |     |
    			  |            |     |
			  |            |     |
		        scheme         +1   TLD
			  |            |     |
			  |            |     |
		          --------------------
		                   |
		                   |
	     	                  SITE
\end{lstlisting}


\textbf{NOTE:} You may come across the term "effective top-level domain" (eTLD). This is just a way of accounting for the reserved multipart suffixes that are treated as top-level domains in practice, such as .co.uk.

\subsection*{What's the difference between a site and an origin?}
 The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one. Although they're closely related, it's important not to use the terms interchangeably as conflating the two can have serious security implications.\\

Two URLs are considered to have the same origin if they share the exact same scheme, domain name, and port. Although note that the port is often inferred from the scheme. 
\begin{lstlisting}[frame=single]
			   https://app.example.com
		 	  |                       |
		    	  |                       |
		  	  -------------------------
		              	      |
		               	      |
	     	        	    origin  
\end{lstlisting}

\begin{table}[h]
\centering
\begin{tabular}{>{\ttfamily}l>{\ttfamily}lcc}
\toprule
\textrm{Request from} & \textrm{Request to} & \textrm{Same-site?} & \textrm{Same-origin?} \\
\midrule
https://example.com & https://example.com & Yes & Yes \\
https://app.example.com & https://intranet.example.com & Yes & No: mismatched domain name \\
https://example.com & https://example.com:8080 & Yes & No: mismatched port \\
https://example.com & https://example.co.uk & No: mismatched eTLD & No: mismatched domain name \\
https://example.com & http://example.com & No: mismatched scheme & No: mismatched scheme \\
\bottomrule
\end{tabular}
\label{tab:same-site-origin}
\end{table}

\subsection*{How does SameSite work?}
SameSite works by enabling browsers and website owners to limit which cross-site requests, if any, should include specific cookies. This can help to reduce users' exposure to CSRF attacks, which induce the victim's browser to issue a request that triggers a harmful action on the vulnerable website. As these requests typically require a cookie associated with the victim's authenticated session, the attack will fail if the browser doesn't include this.\\

All major browsers currently support the following SameSite restriction levels: 
\begin{itemize}
	\item Strict
	\item Lax
	\item None
\end{itemize}
\newpage
Developers can manually configure a restriction level for each cookie they set, giving them more control over when these cookies are used. To do this, they just have to include the SameSite attribute in the Set-Cookie response header, along with their preferred value: 

\begin{lstlisting} [frame=single]
Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict
\end{lstlisting}
\vspace{0.25cm}
\textbf{NOTE:} If the website issuing the cookie doesn't explicitly set a SameSite attribute, Chrome automatically applies Lax restrictions by default. This means that the cookie is only sent in cross-site requests that meet specific criteria, even though the developers never configured this behavior. As this is a proposed new standard, we expect other major browsers to adopt this behavior in future. 

\begin{enumerate}
	\item \textbf{Strict}
If a cookie is set with the SameSite=Strict attribute, browsers will not send it in any cross-site requests. In simple terms, this means that if the target site for the request does not match the site currently shown in the browser's address bar, it will not include the cookie. 
	\item \textbf{Lax}
Lax SameSite restrictions mean that browsers will send the cookie in cross-site requests, but only if both of the following conditions are met: 
\begin{itemize}
 \item The request uses the GET method. 
 \item The request resulted from a top-level navigation by the user, such as clicking on a link.
\end{itemize}
 This means that the cookie is not included in cross-site POST requests, for example. As POST requests are generally used to perform actions that modify data or state (at least according to best practice), they are much more likely to be the target of CSRF attacks.

Likewise, the cookie is not included in background requests, such as those initiated by scripts, iframes, or references to images and other resources.
	\item \textbf{None}
 If a cookie is set with the SameSite=None attribute, this effectively disables SameSite restrictions altogether, regardless of the browser. As a result, browsers will send this cookie in all requests to the site that issued it, even those that were triggered by completely unrelated third-party sites.\\

With the exception of Chrome, this is the default behavior used by major browsers if no SameSite attribute is provided when setting the cookie. \\

When setting a cookie with SameSite=None, the website must also include the Secure attribute, which ensures that the cookie is only sent in encrypted messages over HTTPS. Otherwise, browsers will reject the cookie and it won't be set. 
\begin{lstlisting} [frame=single]
Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure
\end{lstlisting}
\end{enumerate}

\section*{General Testing Methodology for CSRF with SameSite Bypass}

\subsection*{1. Reconnaissance Phase}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.75\textwidth}}
    \toprule
    \textbf{Task} & \textbf{Description} \\
    \midrule
    Identify endpoints & Map all state-changing endpoints (email change, password reset, profile updates, etc.) \\
    Authentication analysis & Document authentication mechanism and session management \\
    CSRF token check & Verify if CSRF tokens are implemented and their predictability \\
    Request flow mapping & Document the complete request flow for sensitive operations \\
    \bottomrule
\end{tabular}

\subsection*{2. Cookie Analysis}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.75\textwidth}}
    \toprule
    \textbf{Check} & \textbf{Analysis Points} \\
    \midrule
    Set-Cookie headers & Examine login responses for cookie settings \\
    SameSite attributes & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item No SameSite specified $\rightarrow$ defaults to Lax
        \item SameSite=Lax $\rightarrow$ GET requests with top-level navigation allowed
        \item SameSite=Strict $\rightarrow$ more restrictive (requires same-site context)
        \item SameSite=None $\rightarrow$ requires Secure flag
    \end{itemize} \\
    Cookie scope & Domain and path settings analysis \\
    \bottomrule
\end{tabular}

\subsection*{3. Endpoint Testing}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Test} & \textbf{Procedure} \\
    \midrule
    HTTP method testing & Test if endpoints accept both GET and POST methods \\
    Method override techniques & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item \texttt{\_method} parameter (Ruby, Laravel)
        \item \texttt{X-HTTP-Method-Override} header
        \item Framework-specific overrides
    \end{itemize} \\
    Parameter testing & Verify parameter acceptance in GET query strings vs POST body \\
    \bottomrule
\end{tabular}

\subsection*{4. Client-Side Redirect Analysis (for SameSite=Strict Bypass)}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Step} & \textbf{Procedure} \\
    \midrule
    Identify redirect gadgets & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Find client-side redirects in application flow
        \item Look for confirmation pages with automatic redirects
        \item Identify JavaScript that handles navigation
        \item Search for URL parameters that influence redirect targets
    \end{itemize} \\
    Analyze redirect logic & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Study JavaScript files for redirect mechanisms
        \item Identify dynamic URL construction
        \item Check for parameter injection points
        \item Test path traversal in redirect parameters
    \end{itemize} \\
    Test redirect control & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Modify parameters to control redirect destination
        \item Use path traversal (../) to access other endpoints
        \item Verify cookies are sent in redirected request
        \item Confirm same-origin context is maintained
    \end{itemize} \\
    \bottomrule
\end{tabular}

\subsection*{5. SameSite Bypass Vectors}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Vector} & \textbf{Implementation} \\
    \midrule
    Top-level navigation & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item \texttt{window.location}
        \item \texttt{<meta> refresh}
        \item \texttt{<iframe>} with top navigation
        \item Form submission with \texttt{target="\_top"}
    \end{itemize} \\
    Client-side redirect chains & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Abuse application's own redirect mechanisms
        \item Chain multiple client-side redirects
        \item Use parameter injection to control final destination
        \item Maintain same-site context through redirect flow
    \end{itemize} \\
    Browser-specific & Test different browser versions and behaviors \\
    \bottomrule
\end{tabular}

\subsection*{6. Exploit Crafting for SameSite=Strict Bypass}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Step} & \textbf{Procedure} \\
    \midrule
    Chain vulnerabilities & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Combine open redirect with state-changing endpoints
        \item Use path traversal in redirect parameters
        \item Encode parameters to avoid syntax breaks
        \item Test parameter normalization behavior
    \end{itemize} \\
    Construct exploit URL & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Start with vulnerable redirect endpoint
        \item Inject path to target endpoint using ../ sequences
        \item Append target parameters with proper encoding
        \item Ensure final URL points to state-changing action
    \end{itemize} \\
    Delivery mechanism & 
    \begin{itemize}
        \setlength\itemsep{0em}
        \item Use \texttt{<script>} tag with \texttt{document.location}
        \item Implement via \texttt{<iframe>} with navigation
        \item Chain through multiple redirect layers
        \item Test in different browser contexts
    \end{itemize} \\
    \bottomrule
\end{tabular}

\section*{Key Testing Checklist}

\subsection*{Cookie Configuration Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    No explicit SameSite attribute set  \\
    SameSite=Lax with top-level navigation  \\
    SameSite=Strict requiring same-site context  \\
    Cookie without Secure flag on HTTPS sites  \\
    Cross-domain cookie scope issues \\
    \bottomrule
\end{tabular}

\subsection*{Endpoint Vulnerability Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    GET requests accepted for state-changing operations \\
    Method overriding supported (\texttt{\_method}, \texttt{X-HTTP-Method-Override})  \\
    No CSRF tokens or predictable tokens  \\
    Parameters accepted via query string \\
    No Referer header validation  \\
    Client-side redirects with user-controllable parameters  \\
    Path traversal possible in redirect parameters \\
    \bottomrule
\end{tabular}

\subsection*{Redirect Gadget Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    Identify confirmation pages with automatic redirects &  \\
    Locate JavaScript files handling client-side navigation  \\
    Test parameter control over redirect destinations & \\
    Verify path traversal works in redirect parameters & \\
    Confirm cookies are sent during client-side redirects  \\
    Test URL normalization behavior\\
    \bottomrule
\end{tabular}

\subsection*{Exploit Validation Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    Proof-of-concept changes target user state \\
    Works with logged-in user session \\
    Bypasses SameSite=Strict restrictions  \\
    Consistent across different browsers  \\
    Maintains session through redirect chain  \\
    Properly encodes special characters \\
    \bottomrule
\end{tabular}

\subsection*{Common Redirect Gadget Locations}
\begin{itemize}
    \item Comment confirmation pages with automatic redirects
    \item Search result pages with "redirecting..." functionality
    \item Login/logout confirmation pages
    \item Form submission success pages
    \item Payment processing confirmation pages
    \item Any page with meta refresh or JavaScript timeout redirects
\end{itemize}


\subsection*{Some examples}
\begin{lstlisting}[frame=single]
<script>
    document.location = 'https://vulnerable-website.com/account/pay
    ment?recipient=hacker&amount=1000000';
</script>
\end{lstlisting}

\begin{lstlisting}[frame=single]
 <html>
<body>
  <form action="https://vulnerable-website.com/post/comment/confirmation">
<input type="hidden" name="postId" value="&#47;my&#45;account&#47;change&#45
;email&#63;email&#61;efdfr&#64;normal&#45;user&#46;net&amp;submit&#61;1" />
<input type="submit" value="Submit request" />
  </form>
  <script>
document.location = "https://vulnerable-website.com/post/comment/confirmatio
n?postId=../my-account/change-email?email=afr%40normal-user.net%26submit=1";
  </script>
</body>
 </html>
\end{lstlisting}

\begin{lstlisting}[frame=single]
<form action="https://vulnerable-website.com/account/payment" method="POST">
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
\end{lstlisting}







\section*{Bypassing Referer-based CSRF Defenses}

Some applications use the HTTP Referer header to defend against CSRF attacks, typically by verifying that requests originate from the application's own domain. This approach is generally less effective than proper CSRF token validation and can be bypassed using various techniques.

\subsection*{Understanding the Referer Header}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Concept} & \textbf{Description} \\
    \midrule
    Purpose & Contains URL of webpage that linked to the requested resource \\
    Browser behavior & Added automatically when users click links or submit forms \\
    Privacy concerns & Often modified or withheld for privacy reasons \\
    Common misspelling & Incorrectly spelled as "Referer" in HTTP specification \\
    \bottomrule
\end{tabular}

\subsection*{Referer Validation Bypass Techniques}

\subsubsection*{1. Exploiting Absent Referer Header}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Vulnerability} & \textbf{Exploitation Method} \\
    \midrule
    Weak validation & Applications validate Referer when present but skip validation when header is absent \\
    Bypass method & Cause browser to omit Referer header in CSRF request \\
    Implementation & Use \texttt{<meta name="referrer" content="never">} in HTML header \\
    \bottomrule
\end{tabular}

\textbf{Example CSRF PoC with Referer Suppression:}
\begin{lstlisting}[frame=single, basicstyle=\footnotesize\ttfamily]
<html>
  <head>
    <meta name="referrer" content="never">
  </head>
  <body>
    <form action="https://target.com/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="attacker@evil.com">
      <input type="submit" value="Submit">
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
\end{lstlisting}

\subsubsection*{2. Circumventing Domain Validation Logic}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Validation Flaw} & \textbf{Bypass Technique} \\
    \midrule
    Starts-with validation & Place target domain as subdomain of attacker domain \\
    Contains validation & Include target domain in query string or path \\
    Regex weaknesses & Exploit poor regular expression patterns \\
    \bottomrule
\end{tabular}

\newpage

\textbf{Subdomain Bypass Example:}
\begin{lstlisting}[frame=single, basicstyle=\footnotesize\ttfamily]
http://target-domain.com.attacker-evil.com/csrf-poc
\end{lstlisting}

\textbf{Query String Bypass Example:}
\begin{lstlisting}[frame=single, basicstyle=\footnotesize\ttfamily]
http://attacker-evil.com/csrf-poc?target-domain.com
\end{lstlisting}

\subsection*{Browser Referrer Policy Challenges}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Challenge} & \textbf{Solution} \\
    \midrule
    Query string stripping & Modern browsers often strip query strings from Referer by default \\
    Override method & Set \texttt{Referrer-Policy: unsafe-url} header in exploit response \\
    Header spelling & Note: "Referrer-Policy" uses correct spelling (double 'r') \\
    \bottomrule
\end{tabular}

\subsection*{Burp Suite Configuration for Referrer Policy}
\begin{enumerate}
    \item \textbf{Access Proxy Settings}
    \begin{itemize}
        \item Go to \texttt{Proxy â†’ Options} in Burp Suite
        \item Scroll to \texttt{Match and Replace} section
    \end{itemize}
    
    \item \textbf{Create Replacement Rule}
    \begin{itemize}
        \item Click \texttt{Add} to create new rule
        \item Configure with these settings:
        \begin{itemize}
            \item Type: \texttt{Response header}
            \item Match: \texttt{Referrer-Policy}
            \item Replace: \texttt{Referrer-Policy: unsafe-url}
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Activate Rule}
    \begin{itemize}
        \item Ensure rule is checked/enabled
        \item Click \texttt{OK} to save configuration
    \end{itemize}
\end{enumerate}
Now when your browser requests the PoC HTML, Burp will automatically add the correct header to the server's response.

Note $\Longrightarrow$ If you found the CSRF and you will make the POC make first the Referer using realserver then like burpsuite (the vuln web still just a query parameter)
\begin{lstlisting}[frame=single]
Referer:https://burpsuite/?0ae30066047b8a858251259a00ed0054.web-secu
rity-academy.net
\end{lstlisting}

And the POC look like

\begin{lstlisting}[frame=single]
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ae30066047b8a858251259a00ed0054.web-secur
    ity-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="ssf&#64;mdsail&#46;com"/>
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?0ae30066047b8a858251259a00ed0054.web-s
      ecurity-academy.net');
      document.forms[0].submit();
    </script>
  </body>
</html>
\end{lstlisting}

Note $\Longrightarrow$ the last parameter in method "history.pushState" is the query parameter which is the vuln website as you see


\subsection*{General Testing Methodology}

\subsubsection*{1. Referer Header Analysis}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Test} & \textbf{Procedure} \\
    \midrule
    Header presence check & Verify if application checks for Referer header existence \\
    Validation logic & Determine how Referer domain is validated \\
    Absent header handling & Test requests with Referer header completely removed \\
    \bottomrule
\end{tabular}

\subsubsection*{2. Validation Logic Testing}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Test Case} & \textbf{Expected Result} \\
    \midrule
    Subdomain bypass & Application accepts \texttt{target.com.attacker.com} as valid \\
    Query string inclusion & Application accepts Referer with target in query parameters \\
    Path manipulation & Application accepts Referer with target in path \\
    Protocol variations & Test HTTP vs HTTPS Referer handling \\
    \bottomrule
\end{tabular}

\subsubsection*{3. Exploit Development}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.7\textwidth}}
    \toprule
    \textbf{Component} & \textbf{Implementation} \\
    \midrule
    Referer suppression & Use \texttt{<meta name="referrer" content="never">} \\
    Domain spoofing & Craft URLs that appear to originate from target domain \\
    Policy enforcement & Configure \texttt{Referrer-Policy: unsafe-url} \\
    Delivery method & Choose appropriate delivery (iframe, form, script) \\
    \bottomrule
\end{tabular}

\section*{Testing Checklist for Referer-based CSRF Protection}

\subsection*{Header Presence Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    Application rejects requests with no Referer header  \\
    Application accepts requests with missing Referer header  \\
    Validation only occurs when Referer is present \\
    \bottomrule
\end{tabular}

\subsection*{Validation Logic Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    Subdomain bypass works (target.attacker.com)  \\
    Query string bypass works (attacker.com?target.com)  \\
    Path-based bypass works (attacker.com/target.com/)  \\
    Protocol validation is properly implemented \\
    Exact domain matching required \\
    \bottomrule
\end{tabular}

\subsection*{Browser Compatibility Tests}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.8\textwidth}c}
    \toprule
    \textbf{Test Case} & \textbf{Check} \\
    \midrule
    Referrer-Policy: unsafe-url forces full URL inclusion  \\
    Meta tag referrer suppression works across browsers \\
    Query strings are preserved in Referer header \\
    Works in latest browser versions \\
    \bottomrule
\end{tabular}

\subsection*{Defense Recommendations}
\begin{itemize}
    \item \textbf{Avoid Referer-based validation} - Use multiple layers of CSRF protection
    \item \textbf{If using Referer} - Implement strict exact-domain matching
    \item \textbf{Fail securely} - Reject requests with invalid/missing Referer when expected
\end{itemize}
\end{document}